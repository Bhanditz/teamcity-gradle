import java.util.concurrent.ConcurrentHashMap
import jetbrains.buildServer.ComparisonFailureData
import jetbrains.buildServer.ComparisonFailureUtil
import jetbrains.buildServer.agent.AgentRuntimeProperties
import jetbrains.buildServer.messages.serviceMessages.*

/*
* Copyright 2000-2011 JetBrains s.r.o.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

initscript {
  dependencies {
    def teamCityInitLib = System.getenv("TEAMCITY_BUILD_INIT_PATH")
    println "Init lib: ${teamCityInitLib}"
    def classPathFiles = teamCityInitLib.split(File.pathSeparator)
    classpath files(classPathFiles)
  }
}

public class DependencyBasedTestRun {

  def logger

  public DependencyBasedTestRun(Logger logger) {
    this.logger = logger
  }

  public def configureGradle(Gradle gradle) {
    def rootProject = gradle.rootProject
    def isIncremental = System.getenv("ui.gradleRunner.gradle.incremental");
    logger.debug("Recieved following incremental setting: ${isIncremental}")

    if (isIncremental != null && isIncremental.toBoolean()) {
      logger.debug("Will look for affected projects")
      def modifiedProjects = findAffectedProjects(rootProject);

      if (modifiedProjects.empty) {
        logger.debug("No affected projects found. Reporting.")
        def taskName = addReportTaskToProject(rootProject)
        gradle.startParameter.taskNames = [taskName]
      } else {
        gradle.startParameter.taskNames = modifiedProjects.collect { it + ":buildDependents" }
        logger.debug("Will start with following tasks: ${gradle.startParameter.taskNames}")
      }
    }
  }

  private def addReportTaskToProject(Project project) {
    def taskName = "report_nothing_changed"
    while (null != project.tasks.findByName(taskName)) {
      taskName = "_" + taskName
    }

    project.tasks.add(taskName, {
      doFirst({
        System.out.println(new Message("TeamCity runs build in incremental mode and no changes are detected. Nothing to do.", "NORMAL", null))
      })
    })

    return taskName
  }

  private def findAffectedProjects(Project project) {

    if (project.teamcity.containsKey(AgentRuntimeProperties.CHANGED_FILES_FILE_PARAM)) {
      def changedFiles = readChangedFiles(project.teamcity);
      def sourceSetsToProject = readSourceSets(project);

      logger.debug("Modified Files: ${changedFiles}")
      logger.debug("SourceSets to Project: ${sourceSetsToProject}")

      def changedProjects = []
      changedFiles.each { path ->
        sourceSetsToProject.findAll({
          path.startsWith(it.key)
        }).collect(changedProjects) {it.value}
      }

      logger.debug("Changes detected in following projects:")
      logger.debug("${changedProjects}")

      return changedProjects
    }
  }

  private def readSourceSets(Project proj) {
    def result = [:]
    proj.allprojects {
      def collectRelativePath = { File file ->
        def path = proj.relativePath(file.getAbsolutePath()).replace('\\','/')
        result[path] = project.getPath()
      }
      if (delegate.hasProperty("sourceSets")) {
        sourceSets.all*.allSource.srcDirs*.each collectRelativePath
        sourceSets.all*.resources.srcDirs*.each collectRelativePath
      }
    }
    return result
  }

  private def readChangedFiles(Map TCProps) {
    String filename = TCProps["teamcity.build.changedFiles.file"]

    def lines = new File(filename).readLines()
    def personalMatch = /(.*):(.*):<personal>/
    def allMatch = /(.*):(.*):(.*)/

    if (lines.any { it ==~ personalMatch }) {
      return lines.grep(~personalMatch).collect {
        (it =~ personalMatch)[0][1]
      }
    } else {
      return lines.collect {
        (it =~ allMatch)[0][1]
      }
    }
  }
}

public class TeamcityPropertiesListener implements ProjectEvaluationListener {

  public void beforeEvaluate(Project project) {
    loadProps(project);
  }

  public void afterEvaluate(Project project, ProjectState projectState) {
    if (project.hasProperty("teamcity")) {
      loadTestJvmArgs(project);
    }
  }

  private def loadTestJvmArgs(Project project) {
    String jvmArgs = (String) project.teamcity["gradle.test.jvmargs"]
    TaskCollection<Test> testTasks = project.getTasks().withType(Test.class)
    if (jvmArgs != null && testTasks != null) {
      for (Test task: testTasks) {
        final String[] arguments = jvmArgs.split("\n");
        task.jvmArgs(arguments);
      }
    }
  }


  private void loadProps(Project p) {
    String propsFilePath = System.getProperty(AgentRuntimeProperties.AGENT_BUILD_PARAMS_FILE_PROP);
    if (null == propsFilePath) {
      propsFilePath = System.getenv(AgentRuntimeProperties.AGENT_BUILD_PARAMS_FILE_ENV);
    }

    if (null != propsFilePath) {
      File propsFile = p.file(propsFilePath);
      Properties props = new Properties();
      InputStream inStream = null;

      try {
        inStream = new FileInputStream(propsFile);
        props.load(inStream);
      } catch (FileNotFoundException e) {
        log.error(e.getMessage(), e);
      } catch (IOException e) {
        log.error(e.getMessage(), e);
      } finally {
        if (null != inStream) {
          try {
            inStream.close();
          } catch (IOException e) {
            Logger.log(LogLevel.ERROR, "Failed to close file stream!", e);
          }
        }
      }

      p.setProperty("teamcity", props);
    } else {
      p.setProperty("teamcity", new HashMap());
    }
  }
}

public class TeamcityTaskListener implements TaskExecutionListener {

  Map<Task, TeamCityErrorStore> taskMessages = new HashMap<Task, TeamCityErrorStore>();

  public void beforeExecute(Task task) {
    ServiceMessage message;
    if (task instanceof AbstractCompile) {
      task.getLogging().captureStandardError(LogLevel.WARN);
      TeamCityErrorStore errorListener = taskMessages.get(task);
      if (null == errorListener) {
        errorListener = new TeamCityErrorStore();
        taskMessages.put(task, errorListener);
      }
      errorListener.reset();
      task.getLogging().addStandardOutputListener(errorListener);
      message = new CompilationStarted(task.getPath());
    } else {
      message = new BlockOpened(task.getPath());
    }
    System.out.println(message.asString());
  }


  public void afterExecute(Task task, TaskState taskState) {
    ServiceMessage message;
    if (task instanceof AbstractCompile) {
      Throwable failure = taskState.getFailure();
      if (null != failure) {
        final TeamCityErrorStore outputListener = taskMessages.get(task);
        for(String str : outputListener.getMessages()) {
          System.out.println(new Message(str, "ERROR", null).asString()); // compilation failure
        }
      }
      message = new CompilationFinished(task.getPath());
    } else {
      message = new BlockClosed(task.getPath());
    }
    System.out.println(message.asString());
  }

  private class TeamCityErrorStore implements StandardOutputListener {

    private List<String> messages = new LinkedList<String>();

    public void onOutput(CharSequence chars) {
      String[] strings = chars.toString().split('(\\n|\\r)*$');
      for(String str : strings) {
        if (str.trim().length() > 0) {
          messages.add(str);
        }
      }
    }

    public List<String> getMessages () {
      return messages;
    }

    public void reset() {
      messages.clear();
    }
  }

}


public class TeamcityTestListener {
  def workerCodes = new ConcurrentHashMap();
  def root;

  String findFlowId(TestDescriptor desc) {
    String code = "";
    while ((null != desc) && ((code = workerCodes.get(desc)) == null)) {
      desc = desc.getParent();
    }
    return code;
  }

  /**
   * Called before a test suite is started.
   * @param suite The suite whose tests are about to be executed.
   */
  public void beforeSuite(TestDescriptor suite) {
    if (null == suite.getParent()) {
      root = suite;
    }
    String code = "";
    if (suite.getParent() == root) {
      // assume, we have worker thread descriptor here
      code = workerCodes.get(suite);
      if (null == code) {
        code = "" + System.identityHashCode(suite);
        String oldCode = workerCodes.putIfAbsent(suite, code);
        if (null != oldCode) {
          code = oldCode;
        }
      }
      return; // do not report service message for workers
    }

    if (null != suite.getParent()) { // do not report root empty suite
      ServiceMessage msg = new TestSuiteStarted(suite.getName());
      msg.setFlowId(findFlowId(suite));
      System.out.println(msg.asString());
    }
  }

  /**
   * Called after a test suite is finished.
   * @param suite The suite whose tests have finished being executed.
   * @param result The aggregate result for the suite.
   */
  public void afterSuite(TestDescriptor suite, TestResult result) {
    if (null != suite?.getParent()?.getParent()) { // do not report root empty suite and workers
      ServiceMessage msg = new TestSuiteFinished(suite.getName());
      msg.setFlowId(findFlowId(suite));
      System.out.println(msg.asString());
    }
  }

  /**
   * Called before a test is started.
   * @param testDescriptor The test which is about to be executed.
   */
  public void beforeTest(TestDescriptor testDescriptor) {
    String testName = getTestName(testDescriptor)
    ServiceMessage msg = new TestStarted(testName, true, null);
    msg.setFlowId(findFlowId(testDescriptor));
    System.out.println(msg.asString());
  }

  /**
   * Called after a test is finished.
   * @param testDescriptor The test which has finished executing.
   * @param result The test result.
   */
  public void afterTest(TestDescriptor testDescriptor, TestResult result) {
    String testName = getTestName(testDescriptor);
    ServiceMessage msg;
    switch (result.getResultType()) {
      case org.gradle.api.tasks.testing.TestResult.ResultType.FAILURE:
        ComparisonFailureData cfd = ComparisonFailureUtil.extractComparisonFailure(result.getException());
        if (cfd != null) {
          msg = new TestFailed(testName, result.getException(), cfd.getActual(), cfd.getExpected());
        } else {
          msg = new TestFailed(testName, result.getException());
        }
        msg.setFlowId(findFlowId(testDescriptor));
        System.out.println(msg.asString());
        break;
      case org.gradle.api.tasks.testing.TestResult.ResultType.SKIPPED:
        msg = new TestIgnored(testName, "");
        msg.setFlowId(findFlowId(testDescriptor));
        System.out.println(msg.asString());
        break;
    };

    final int duration = (int) (result.getEndTime() - result.getStartTime());
    msg = new TestFinished(testName, duration);
    msg.setFlowId(findFlowId(testDescriptor));
    System.out.println(msg.asString());
  }

  public void onOutput(testDescriptor, outputEvent) {
    def testName = getTestName(testDescriptor)
    def msg
    switch (outputEvent.getDestination()) {
      case TestOutputEvent.Destination.StdErr:
        msg = new TestStdErr(testName, outputEvent.getMessage())
        break
      case TestOutputEvent.Destination.StdOut:
        msg = new TestStdOut(testName, outputEvent.getMessage())
        break
    }
    msg.setFlowId(findFlowId(testDescriptor))
    System.out.println(msg.asString())
  }

  private String getTestName(TestDescriptor testDescriptor) {
    return testDescriptor.getClassName() + "." + testDescriptor.getName()
  }

  def testListenerDelegate = [
          beforeSuite :  { suite ->
            this.beforeSuite(suite)
          },

          afterSuite : { suite, result ->
            this.afterSuite(suite, result)
          },

          beforeTest : { testDescriptor ->
            this.beforeTest(testDescriptor)
          },

          afterTest : { testDescriptor, result ->
            this.afterTest(testDescriptor, result)
          }]

  def testOutputDelegate = [
          onOutput : { testDescriptor, outputEvent ->
            this.onOutput(testDescriptor, outputEvent)
          }]

}




def teamcityTestListener = new TeamcityTestListener()
gradle.addListener(teamcityTestListener.testListenerDelegate as TestListener)

try {
  def testOutputListenerClass = Class.forName("org.gradle.api.tasks.testing.TestOutputListener",false, getClass().getClassLoader());
  gradle.addListener(teamcityTestListener.testOutputDelegate.asType(testOutputListenerClass));
  logger.debug("added teamCityListener as ${testOutputListenerClass.getName()}")

} catch (ClassNotFoundException e) {
  logger.debug("Could not load TestOutputListener class. Test out will not be available")
}

gradle.addListener(new TeamcityPropertiesListener())
gradle.useLogger(new TeamcityTaskListener())
gradle.projectsEvaluated { new DependencyBasedTestRun(logger).configureGradle(it) }
